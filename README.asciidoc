= ShrinkWrap Maven Plugin

This plugin allows the developer to define the artifact assembly for a Maven module as a ShrinkWrap archive.

At the moment, it's a POC prototype.  Super unstable; here for early feedback.

== Reason for Being

ShrinkWrap and Arquillian have cut the development lifecycle by skipping the build; using the IDE's incremental compilation features, they do not require a full Maven run inbetween tests or deployments.

Unfortunately, this puts users in the position of often having to reconstruct the "real" build artifacts generated by Maven in their test cases.

This Plugin allows a user to define the artifact's makeup once in ShrinkWrap, allowing that definition to become the "real" artifact used by Maven as well.

Additionally, this is a handy way to use ShrinkWrap's friendly API as an alternative to the Assembly or Shade Plugins.

== Building

This is a normal Maven project.  Simply execute `mvn clean install`.

NOTE: For the moment this project has a dependency on an unreleased ShrinkWrap `2.0.0-alpha-X-SNAPSHOT`; you'll need to check this out of https://github.com/shrinkwrap/shrinkwrap and install into your local `m2` repository before building.  This should be resolved before too long.

== Usage

Set the following two pieces of configuration in your project's `pom.xml`:

1) The packaging element must be set to `shrinkwrap`:

```
<project>
...
	<packaging>shrinkwrap</packaging>
...
</project>

```

2) Declare the plugin in the `build` element:

```
<project>
...
	<!-- Build Configuration -->
	<build>
		<plugins>
			<plugin>
				<groupId>org.jboss.shrinkwrap</groupId>
				<artifactId>shrinkwrap-maven-plugin</artifactId>
				<version>[[SOME_VERSION]]</version>
				<extensions>true</extensions>
			</plugin>
		</plugins>
	</build>
...
</project>
```

3) Construct your build artifact using the ShrinkWrap API, returning any `Archive` type.  You may use anything available to the test classpath.  For instance, by placing a class under `src/test/java`:

```
package org.jboss.shrinkwrap.plugins.maven.testproject;

import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import java.util.Map;

public class ShrinkWrapArtifact {

    public static JavaArchive build() {
        return ShrinkWrap.create(JavaArchive.class).
                // Add a class from src/main/java
                addClass(TestClass.class).
                // Add a class from the JDK
                addClass(Map.class).
                // Add a class from the test classpath
                addClass(Assert.class);
    }
}
```

The above defines an artifact which will have three classes in it; a `TestClass` from our test project, `Map` from the Java Collections API, and `Assert` from JUnit, a test dependency.

NOTE: The POC has yet to implement a way for the Plugin to know where the artifact is defined and is currently hardcoded.  This is to change shortly.

== Result

Upon running the Maven build, you'll be left with an artifact similar to what you might expect as generated from the Maven JAR Plugin, ie. `myproject-1.0.0-alpha-1-SNAPSHOT.jar`.

However, the contents will contain those not from `src/main`, but as constructed using the ShrinkWrap API:

```
$ jar -tvf myproject-1.0.0-alpha-1-SNAPSHOT.jar
   346 Fri Feb 23 00:25:14 EST 2018 org/jboss/shrinkwrap/plugins/maven/testproject/TestClass.class
     0 Fri Feb 23 00:25:14 EST 2018 org/
     0 Fri Feb 23 00:25:14 EST 2018 org/jboss/
     0 Fri Feb 23 00:25:14 EST 2018 org/jboss/shrinkwrap/
     0 Fri Feb 23 00:25:14 EST 2018 org/jboss/shrinkwrap/plugins/
     0 Fri Feb 23 00:25:14 EST 2018 org/jboss/shrinkwrap/plugins/maven/
     0 Fri Feb 23 00:25:14 EST 2018 org/jboss/shrinkwrap/plugins/maven/testproject/
  4127 Fri Feb 23 00:25:14 EST 2018 java/util/Map.class
     0 Fri Feb 23 00:25:14 EST 2018 java/
     0 Fri Feb 23 00:25:14 EST 2018 java/util/
  8920 Fri Feb 23 00:25:14 EST 2018 org/junit/Assert.class
     0 Fri Feb 23 00:25:14 EST 2018 org/junit/
```